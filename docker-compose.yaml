services:
  postgres-db:
    image: postgres:16.4
    container_name: postgres_db
    #restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: 1VMgjjD3D4kW
      POSTGRES_DB: postgres
    networks:
      - backend-database-net      
    ports:
      - "5432:5432"
    volumes:
      # mount the SQL file directly in Compose
      # the SQL runs automatically on the first container startup
      # subsequent restarts will not re-run the SQL file unless 
      # you delete the database volume:
      - ./backend/budget_2025-05-08.sql:/docker-entrypoint-initdb.d/init_db.sql
      # Mount the host's EBS-backed directory into the container to store postgres DB on it:
      - /mnt/pgdata/data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U myuser -d mydatabase"]
      interval: 10s      # run every 10 seconds
      timeout: 5s        # fail if takes longer than 5s
      retries: 5         # mark as unhealthy after 5 failures
      start_period: 20s  # wait 20s before first check (gives Postgres time to boot)  

  backend:
    build: ./backend
    ports: 
      - "5005:5005"
# Docker injects the values as environment variables. 
# Node.js apps (if they use dotenv) will still work, because dotenv reads from the 
# environment if .env is not present.
# By default Docker respects a .dockerignore file (to avoid that it's copied to the image)
    env_file:
      - ./backend/.env
      - ./backend/.env.local
    networks:
      - backend-database-net
      - backend-frontend-net
    depends_on:
      postgres-db:
        condition: service_healthy

  frontend:
    build: ./frontend
    env_file:
      - ./frontend/.env
      - ./frontend/.env.local
    ports: 
      - "80:3000"
    networks:
      - backend-frontend-net

networks:
  backend-database-net:
    driver: bridge
  backend-frontend-net:
    driver: bridge

volumes:
  db_data:
